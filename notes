working with hardware: 

Kernel - the interface between HW and SW for the computer. 

uname - displayi nfo about the kernel

uanme -r/uname-a to print kernel version
	divided into Kernel space and User space. 

dmesg - display messages from the ring buffer of the Kernel

less - to redirect the messages

grep - to search for specific keywords within those messages

	Example: demsg | grep -i usb 
	search for the keyword "USB" within the dmesg

Udev:

database with HW info - devices that are connected to the system

udevadm - command the udev database

udevadm info - query the database for device info.
	Example: udevadm info --query=path --name=/dev/sda5

udevadm monitor - listening for Uevents

lspci - list pci 
PCI - PERIPHERAL COMPONENT INTERCONNECT
show info about all PCI-devices configured in the system

lsblk - list block devices
lists info about block devices

sda - physical drive
|_sda1 - partition 1
|_sda2 - partition 2
|_sda3 - partition 3
|_sda4 - partition 4
|_sda5 - partition 5

lscpu - list cpu info

lsmem - list memory info
lsmem --summary - get summary of memory info 

free - show the available vs. used memory. -m for megabytes -k for kilobytes -g for gigabytes

lshw - get detailed hardware info 

Linux Boot sequence:
Starts after POST. BIOS executes the boot code from the boot device, located on the 1st sector of the HDD. In linux, it's located in /boot filesystem
POST> Boot loader(currently GRUB2)>Kernel initialization> INIT process(currently systemd)
* GRUB2: GRand Unified Boot loader2
* INIT process: up until recently - System V INIT, aka SYS5. Was used on RHEL 6 and CentOS 6. Current standard - systemd.
systemd can run service startup in parallel, rather than linear, making it quicker and more efficient than sys5.

Kernels are stored on the drive in a compressed form to save space. during startup sequence, the kernel decompresses and initializes hardware, starts memory management proesses and other things. 

check what INIT process is used by the system:
ls -l /sbin/init


Runlevels:

there's more than one way to use linux - there's Graphical User Interface - GUI , and there's Command Line Interface - CLI.

the "way to use" linux is called a Runlevel, and it can be checked with the command runlevel. 
GUI is runlevel 5 and CLI is runlevel 3.

Targets:

The term runlevels is used in the sysV init systems. These have been replaced by systemd targets in systemd based systems.

The complete list of runlevels and the corresponding systemd targets can be seen below:

runlevel 0 -> poweroff.target

runlevel 1 -> rescue.target

runlevel 2 -> multi-user.target

runlevel 3 -> multi-user.target

runlevel 4 -> multi-user.target

runlevel 5 -> graphical.target

runlevel 6 -> reboot.target

systemd target for GUI is graphical.target.
systemd target for CLI is multiuser.target.

Check current target: 

systemctl get-default

ls -ltr /etc/systemd/system/default.target

WHAT IS LTR?! 

l: This is for the long listing of the contents. It shows one file in each line with additional info such as permissions, ownership, size, timestamps etc.
t: This one sorts the long listing output based on time.
r: This one reverses the order of ls command output.

running LTR means you get the entire list, sorted by date, earliest to latest, in a top to bottom order.

change the default target: 
Example - move from GUI to CLI 
systemctl set-default multi-user.target


File types:
EVERYTHING IS A FILE IN LINUX

3 types of files: 

Regular File - pics, scripts, configs, data, text etc. 

Directory - contains regular files. /home/username /root /etc/systemd/ /home/bob/code-library

Special files:
a special file belongs to one of the following 5 sub categories:

* Character files: represent devices. found in /dev and allows the OS to communicate with I/O devices serially. Devices such as a Mouse and Keyboard.
* Block files: represent block devices. found in /dev. a block device and reads from and writes to the device in chunks of data called blocks. example: Hard disk and RAM.
* Link files: used when there's a need to associate a set of file data more than one name. 2 types
	* hard link: for 2 or more file names that share the same block of data on the physical disk. delete any of the links, and the data is gone, even if the other link is still intact. 
	* soft link: known as a symbolic link, or symlink. similarly to shortcuts in Windows, these point to another file. Delete the symlink and the data remains intact
* Socket files: enable the communication between 2 processes. 
* Named pipes: allow connecting between processes by using one process as an input to the other. the data flow in pipes is unidirectional - data only goes one way, from the 1st process to the 2nd.







